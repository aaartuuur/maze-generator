Прима:
    если нужен надежный и универсальный
    сложность O(nlog(n))

Рекурсивный backtracker:
    подходит для небольших полей
    прост в реализации
    на небольших полях запутанность понравилась больше остальных(все говорят часто имеет один длинный путь)
    из-за рекурсивности не может строить большие поля (переполнение стека)
    сложность O(n)

Крускал:
    написал дипсик, он же сказал что лабиринты более случайные
    сложность O(nlog(n))

Клеточный автомат:
    не идеальный лабиринт(остальные идеальные)
    возможны изолированные комнаты
    сложность O(n)


Прима:
    всё поле заполняется #
    берется начальная точка _
    потом в лист по рандомному приоритету заносятся координаты
    клеток (через одну от начальной [(0, 2), (2, 0), (0, -2), (-2, 0)]) и координаты родительской
    потом из листа берется клетка
        если это #:
            то клетка становится _ и ломается стенка _ между родительской и текущей
            в лист с помощью рандомного приоритета также заносится координаты близких (через одну от текущей)
            клеток и координаты текущей клетки в данном случае она родительская


Рекурсивный backtracker:
    всё поле заполняется #
    берется начальная точка _
    в рандомном направлении  [(0, 2), (2, 0), (0, -2), (-2, 0)] ломаем клетку и проход между ними,
    если этак клетка уже не сломана и мы не вышли за пределы
    потом уже от этой клетки идем в любом направлении ...
    когда ходов не осталось у этой клетки возвращаемся к предыдущей


Крускала:
    всё поле заполняется #
    делаем изолированные комнаты _ размером в одну клетку
    потом делаем список стен которые можно сломать, перемешиваем
    изначально каждая комната отдельная группа
    ломаем только те стены которые объединяют 2 группы иначе если мы сломаем стену 2 комнат из одной группы
    получится цикл
    делаем до тех пор пока не будет 1 группа